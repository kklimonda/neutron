From 5a3dadc60103a8c2dc88446fe4b2412c9bdf0790 Mon Sep 17 00:00:00 2001
From: Saverio Proto <saverio.proto@switch.ch>
Date: Thu, 21 Apr 2016 16:50:07 +0200
Subject: [PATCH] Check if namespace exists before getting devices

If a neutron router has no ports defined, its namespace is deleted
by the cronjob /etc/cron.d/neutron-l3-agent-netns-cleanup.
It is required to check if the namespace exists before calling
iproute2 commands against the namespace.
It is not enough for the string of the namespace uuid to be defined,
the namespace must really exist on the network node.
This patch checks if the namespace exists when calling get_devices().
Otherwise the agent log file will be flooded with messages like
Cannot open network namespace "qrouter-<uuid>": No such file or directory
Failed to process compatible router '<uuid>'

Related-bug: 1573073

Change-Id: I744ef11529f9da5cbfdb812de0b35b95f9d078bb
(cherry picked from commit 7675495f260daf0174f4e04b36279513889df19a)
---
 neutron/agent/linux/ip_lib.py                 | 21 +++++++++++++++------
 neutron/tests/unit/agent/linux/test_ip_lib.py | 18 ++++++++++++++++++
 2 files changed, 33 insertions(+), 6 deletions(-)

--- a/neutron/agent/linux/ip_lib.py
+++ b/neutron/agent/linux/ip_lib.py
@@ -124,12 +124,21 @@
             # we call out manually because in order to avoid screen scraping
             # iproute2 we use find to see what is in the sysfs directory, as
             # suggested by Stephen Hemminger (iproute2 dev).
-            output = utils.execute(['ip', 'netns', 'exec', self.namespace,
-                                    'find', SYS_NET_PATH, '-maxdepth', '1',
-                                    '-type', 'l', '-printf', '%f '],
-                                   run_as_root=True,
-                                   log_fail_as_error=self.log_fail_as_error
-                                   ).split()
+            try:
+                cmd = ['ip', 'netns', 'exec', self.namespace,
+                       'find', SYS_NET_PATH, '-maxdepth', '1',
+                       '-type', 'l', '-printf', '%f ']
+                output = utils.execute(
+                    cmd,
+                    run_as_root=True,
+                    log_fail_as_error=self.log_fail_as_error).split()
+            except RuntimeError:
+                # We could be racing with a cron job deleting namespaces.
+                # Just return a empty list if the namespace is deleted.
+                with excutils.save_and_reraise_exception() as ctx:
+                    if not self.netns.exists(self.namespace):
+                        ctx.reraise = False
+                        return []
         else:
             output = (
                 i for i in os.listdir(SYS_NET_PATH)
--- a/neutron/tests/unit/agent/linux/test_ip_lib.py
+++ b/neutron/tests/unit/agent/linux/test_ip_lib.py
@@ -282,6 +282,24 @@
         self.assertTrue(fake_str.split.called)
         self.assertEqual(retval, [ip_lib.IPDevice('lo', namespace='foo')])
 
+        @mock.patch('neutron.agent.common.utils.execute')
+        def test_get_devices_namespaces_ns_not_exists(self, mocked_execute):
+            mocked_execute.side_effect = RuntimeError(
+                "Cannot open network namespace")
+            with mock.patch.object(ip_lib.IpNetnsCommand, 'exists',
+                                   return_value=False):
+                retval = ip_lib.IPWrapper(namespace='foo').get_devices()
+                self.assertEqual([], retval)
+
+        @mock.patch('neutron.agent.common.utils.execute')
+        def test_get_devices_namespaces_ns_exists(self, mocked_execute):
+            mocked_execute.side_effect = RuntimeError(
+                "Cannot open network namespace")
+            with mock.patch.object(ip_lib.IpNetnsCommand, 'exists',
+                                   return_value=True):
+                self.assertRaises(RuntimeError,
+                                  ip_lib.IPWrapper(namespace='foo').get_devices)
+
     def test_get_namespaces_non_root(self):
         self.config(group='AGENT', use_helper_for_ns_read=False)
         self.execute.return_value = '\n'.join(NETNS_SAMPLE)
